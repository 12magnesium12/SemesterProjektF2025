#include <modbus/modbus.h>  // Til Modbus TCP kommunikation
#include <sqlite3.h>        // Til SQLite databasehåndtering
#include <iostream>
#include <cstring>
#include <csignal>          // Til signal-håndtering (Ctrl+C)
#include <unistd.h>
#include <cstdlib>
#include <cerrno>
#include <thread>
#include <chrono>           // Til timer funktion
#include <pigpio.h>         // Til GPIO kontrol på Raspberry Pi

/*
Kompilering:
    g++ -std=c++17 -o ModbusMedGripper ModbusMedGripper.cpp -lmodbus -lsqlite3 -lpthread -lpigpio
Kørsel:
    sudo ./ModbusMedGripper
*/

// Globale pointere og variabler til Modbus og SQL
modbus_t *ctx = nullptr;           	// Modbus kontekst
modbus_mapping_t *mb_mapping = nullptr; // Modbus mapping (coils, inputs)
int server_socket = -1;           	// TCP server socket
int previous_coil_value = -1;     	// Gemmer tidligere coil-værdi
int previous_input_value = -1;    	// Gemmer tidligere input-værdi
sqlite3* db = nullptr;             	// SQLite database pointer
char* errMsg = nullptr;            	// Fejlbeskeder fra SQL

// GPIO konstanter til sensorer og motor
const int GPIO_23 = 23; // Åben-sensor (input)
const int GPIO_26 = 26; // Lukket-sensor (input)
const int GPIO_8 = 8;   // Motor: Åben (output)
const int GPIO_7 = 7;   // Motor: Lukke (output)

// Funktion til korrekt nedlukning, f.eks. ved Ctrl+C
void cleanup(int signum) {
    std::cout << "\nCleaning up and exiting...\n";
    if (server_socket != -1) close(server_socket);       // Luk TCP socket
    if (ctx) modbus_free(ctx);                           // Frigiv Modbus context
    if (mb_mapping) modbus_mapping_free(mb_mapping);     // Frigiv Modbus mapping
    if (db) sqlite3_close(db);                           // Luk database
    gpioTerminate();                                     // Stop pigpio
    exit(0);
}

int main() {
    // Oprettelse af database og tabel, hvis de ikke findes
    int rc = sqlite3_open("gripper_database.db", &db);
    if (rc) {
        std::cerr << "Cannot open database: " << sqlite3_errmsg(db) << std::endl;
        return 1;
    }
    // SQL-kommando til at oprette tabellen 'box' med id og size
    const char* sqlCreate = "CREATE TABLE IF NOT EXISTS box("
                            "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                            "size TEXT NOT NULL);";
    rc = sqlite3_exec(db, sqlCreate, nullptr, nullptr, &errMsg);
    if (rc != SQLITE_OK) {
        std::cerr << "Error creating table: " << errMsg << std::endl;
        sqlite3_free(errMsg);
        sqlite3_close(db);
        return 1;
    }

    // Initialisering af pigpio og set GPIO pins
    if (gpioInitialise() < 0) {
        std::cerr << "pigpio initialization failed!" << std::endl;
        return 1;
    }
    gpioSetMode(GPIO_23, PI_INPUT);   // Åben-sensor som input
    gpioSetMode(GPIO_26, PI_INPUT);   // Lukket-sensor som input
    gpioSetMode(GPIO_8, PI_OUTPUT);   // Motor "åben" som output
    gpioSetMode(GPIO_7, PI_OUTPUT);   // Motor "lukke" som output

    // Tilføj cleanup-funktionen når Ctrl+C bruges
    signal(SIGINT, cleanup);

    // Oprettelse af Modbus TCP-server
    ctx = modbus_new_tcp("0.0.0.0", 502); // Lyt på alle netværksinterfaces, på port 502
    if (!ctx) {
        std::cerr << "Kunne ikke oprette Modbus context\n";
        return -1;
    }

    // Allokerer en coil og et input til Modbus mapping
    mb_mapping = modbus_mapping_new(
        1,  // 1 Discrete output (coil)
        1,  // 1 Discrete input
        0, 0 // Ingen holding/input registers
    );
    if (!mb_mapping) {
        std::cerr << "Mapping fejl: " << modbus_strerror(errno) << std::endl;
        modbus_free(ctx);
        return -1;
    }

    // Start TCP-serveren for Modbus
    server_socket = modbus_tcp_listen(ctx, 1);
    if (server_socket == -1) {
        std::cerr << "Lytte-fejl: " << modbus_strerror(errno) << std::endl;
        modbus_free(ctx);
        modbus_mapping_free(mb_mapping);
        return -1;
    }
    std::cout << "Modbus TCP Server kører på port 502...\n";
    modbus_tcp_accept(ctx, &server_socket);

    // Bruges til at huske tidligere sensor-værdier
    int previousVal23 = 0;
    int previousVal26 = 0;

    // Variabler til timing og state for gripperen
    bool isClosing = false;  // Tjek om gripperen er i gang med at lukke
    std::chrono::high_resolution_clock::time_point closeStart; // Tidspunkt hvor lukningen starter

    while (true) {
        // Buffer til at modtage Modbus-forespørgsler
        uint8_t query[MODBUS_TCP_MAX_ADU_LENGTH];
        int rc = modbus_receive(ctx, query);

        // Læs GPIO inputs fra sensorer
        int val23 = gpioRead(GPIO_23);  // Åben-sensor (1 = åben, 0 = ikke åben)
        int val26 = gpioRead(GPIO_26);  // Lukket-sensor (1 = lukket, 0 = ikke lukket)

        // Sæt begge motor outputs LOW, som sikkerhed før næste handling
        gpioWrite(GPIO_8, 0);
        gpioWrite(GPIO_7, 0);

        // --------- GRIPPER-LOGIK ---------
        // Hvis coil[0] = 0 (åben kommando), og gripper ikke allerede er åben (val26==1)
        if (mb_mapping->tab_bits[0] == 0 && val26) {
            std::cout << "Åbner gripper\n";
            gpioPWM(GPIO_8, 0);    // Motor "åben" lav
            gpioPWM(GPIO_7, 50);   // Motor "lukke" PWM for at åbne
            isClosing = false;     // Sæt tilstand til ikke-lukkende
        } 
        // Hvis coil[0] = 1 (luk kommando), og gripper ikke allerede er lukket (val23==1)
        else if (mb_mapping->tab_bits[0] == 1 && val23) {
            std::cout << "Lukker gripper val23: " << val23 << " val26: " << val26 << std::endl;
            gpioPWM(GPIO_7, 0);    // Motor "lukke" lav
            gpioPWM(GPIO_8, 80);   // Motor "åben" PWM for at lukke
            // Start timer hvis vi ikke allerede måler tiden
            if (!isClosing) {
                closeStart = std::chrono::high_resolution_clock::now();
                isClosing = true;
                std::cout << "Starting timer for gripper-close..." << std::endl;
            }
        }

        // Hvis vi er i gang med at lukke og lukket-sensoren går LOW, er vi færdige
        if (isClosing && !val26) {
            auto closeStop = std::chrono::high_resolution_clock::now();   // Stop timer
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(closeStop - closeStart);
            double durationSec = duration.count() / 1000.0;               // Omregn milisekunder til sekunder
            std::string size;

            // Bestem objektstørrelsen ud for tiden
            if (durationSec < 1.1) {
                size = "small";  // Lukning på under 1,1 sek = lille boks
            } else {
                size = "big";    // Lukning på over 1,1 sek = stor boks
            }

            std::cout << "Gripper closed in " << durationSec << " seconds. It was a " << size << " box." << std::endl;

            // Indsæt resultat i SQL-databasen
            std::string sqlInsert = "INSERT INTO box (size) VALUES ('" + size + "');";
            int rc2 = sqlite3_exec(db, sqlInsert.c_str(), nullptr, nullptr, &errMsg);
            if (rc2 != SQLITE_OK) {
                std::cerr << "Error during insert: " << errMsg << std::endl;
                sqlite3_free(errMsg);
            } else {
                std::cout << "Box inserted med size: " << size << std::endl;
            }
            isClosing = false; // Nulstil tilstand
        }

        // Modbus input-signal til UR-robot
        // Sæt input[0] = 1 hvis mindst én endestop-sensor er LOW (ramt grænse)
        if (!val26 || !val23) {
            mb_mapping->tab_input_bits[0] = 1;
            std::cout << "Input is changed to: 1\n";
        } else {
            mb_mapping->tab_input_bits[0] = 0;
            std::cout << "Input is changed to: 0\n";
        }

        // Modbus håndtering af svar ---------
        if (rc > 0) {
            // Besvar Modbus-forespørgslen fra UR-robotten
            modbus_reply(ctx, query, rc, mb_mapping);
        } else if (rc == -1) {
            // Etabler forbindelse igen, hvis mistes
            modbus_tcp_accept(ctx, &server_socket); 
        }
    }

    // Sørger for ordentlig lukning af programmet
    cleanup(0);
    return 0;
}
